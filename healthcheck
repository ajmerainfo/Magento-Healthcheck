#!/usr/bin/ruby

require 'rexml/document'
require 'socket'
require 'optparse'
require 'pathname'

$options = Hash.new
OptionParser.new do |opt|
  opt.on('-v', '--verbose', 'Show all output of commands') { |o| $options[:verbose] = o}
end.parse!

Effects = {
  :off => 0,
  :bright => 1,
  :underline => 4,
  :blink => 5,
  :invert => 7,
  :hide => 8,
  :blackfg => 30,
  :redfg => 31,
  :greenfg => 32,
  :yellowfg => 33,
  :bluefg => 34,
  :magentafg => 35,
  :cyanfg => 36,
  :whitefg => 37,
  :defaultfg => 39,
  :blackbg => 40,
  :redbg => 41,
  :greenbg => 42,
  :yellowbg => 43,
  :bluebg => 44,
  :magentabg => 45,
  :cyanbg => 46,
  :whitebg => 47,
  :defaultbg => 49,
}

def colorize(key)
  effect = Effects[key]
  return "[#{effect}m"
end

class Scannable
  attr_accessor :saved

  @@matches = Hash.new { |hash, key| hash[key] = Hash.new }
  
  def matches
    @@matches[self.class]
  end

  def matches= (newmatches)
    newmatches.each do |key, value|
      @@matches[self.class][key] = value
    end
  end
  
  def header
    puts
    puts "#{colorize(:underline)}#{self.class.superclass}: #{colorize(:bright)}#{label}#{colorize(:off)}"
  end

  def okay(data, test, value)
    data = cleanup(data)
    if test == :save
      saved[value] = data
      return true
    else
      if value.class == Symbol
        value = Integer saved[value]
      end
      if test == "="
        return ((Integer data) == value)
      elsif test == ">"
        return ((Integer data) > value)
      elsif test == "<"
        return ((Integer data) < value)
      elsif test == ">="
        return ((Integer data) >= value)
      elsif test == "<="
        return ((Integer data) <= value)
      elsif test == "eq"
        return (data == value)
      elsif test == "ne"
        return (data != value)
      elsif test == :okay
        return true
      elsif test == :alsocheck
        unless $checks.include? [value, data]
          $checks.unshift [value, data]
        end
        return true
      else
        return false
      end
    end
  end

  def cleanup(value)
    return(value)
  end
  
  def scanline(line)
    match = false
    matches.each do |key, tests|
      if matchdata = (key.match line)
        match = true
        (1..tests.length).to_a.reverse.each do |i|
          testpairs = tests[i-1]
          endinsert = nil
          while test = testpairs.shift
            value = testpairs.shift
            if okay(matchdata[i], test, value)
              unless endinsert
                endinsert = colorize(:off) + colorize(:bright)
                begininsert = colorize(:greenfg)
              end
            else
              if test == :flag
                endinsert = colorize(:off) + ' ' + colorize(:invert) + "#{value}" + colorize(:off) + colorize(:bright)
              else
                endinsert = colorize(:off) + ' ' + colorize(:invert) + "(should be #{test} #{value})" + colorize(:off) + colorize(:bright)
              end
              begininsert = colorize(:redbg)
            end
          end
          line.insert(matchdata.end(i), endinsert)
          line.insert(matchdata.begin(i), begininsert)
        end
        line = (colorize(:bright) + line + colorize(:off))
      end
    end
    if match or $options[:verbose]
      return line
    end
  end
  
  def scan
    self.saved = Hash.new
    header
    openstream do |s|
      while (line = s.gets)
        if (line = scanline line.chop)
          puts line
        end
      end
    end
  end
end

class ShellCommand < Scannable
  attr_reader :command
  
  def initialize(command = '')
    @command = command
  end

  def label
    cmd
  end
  
  def openstream
    open "|#{cmd} 2>&1" do |s|
      yield s
    end
  end
end

class Cache < ShellCommand
  attr_reader :hostname
  attr_reader :port
  
  def initialize(hostname, port)
    @hostname = hostname
    @port = port
  end

  def quitcmd
    "quit"
  end

  def label
    "#{self.class} at #{hostname}:#{port}"
  end

  def openstream
    TCPSocket.open(hostname, port) do |s|
      s.puts cmd + "\r"
      s.puts quitcmd + "\r"
      yield s
    end
  end
end

class Memcached < Cache
  def cmd
    "stats"
  end

  def initialize(*args)
    super
    self.matches = {
      /STAT evictions (\d+)/ => [["=", 0]],
    }
  end
end

class Redis < Cache
  def cmd
    "info"
  end

  def initialize(*args)
    super
    @@matches[Sysctl][/vm.overcommit_memory = (\d+)/] = [["=", 1]]
    self.matches = {
      /evicted_keys:(\d+)/ => [["=", 0]],
      /connected_clients:(\d+)/ => [[">", 0]],
    }
  end
end

class Sysctl < ShellCommand
  def cmd
    "sysctl -a"
  end

  def initialize(*args)
    super
    self.matches = {
      /net.ipv4.tcp_tw_recycle = (\d+)/ => [["=", 1]],
      /net.ipv4.tcp_tw_reuse = (\d+)/ => [["=", 1]],
      /net.ipv4.tcp_fin_timeout = (\d+)/ => [["=", 10]],
    }
  end
end

class Netstat < ShellCommand
  def cmd
    "netstat -nap"
  end
end

class Iostat < ShellCommand
  def cmd
    "iostat -dx"
  end
end

class Dmesg < ShellCommand
  def cmd
    "dmesg"
  end
end

class Free < ShellCommand
  def cmd
    "free -mo"
  end
end

class Uptime < ShellCommand
  def cmd
    "uptime"
  end
end

class Ps < ShellCommand
  def cmd
    'ps aux'
  end

  def initialize(*args)
    super
    self.matches = {
      /root.*\s([\/a-z]*apache2?)/ => [[:alsocheck, Apache]],
      /root.*\s([\/a-z]*httpd)/ => [[:alsocheck, Apache]],
      /nginx: master process (\S*)/ => [[:alsocheck, Nginx]],
      /(memcached).*-m (\d+)/ => [[:okay], [">", 1024]],
      /redis-server\s+(\S+)/ => [[:alsocheck, RedisConf]],
    }
  end
  
end

class Httpdt < ShellCommand
  def cmd
    "#{command} -t"
  end

  def initialize(*args)
    super
    self.matches = {
      /(.*warn.*)/ => [[:flag, "!!!! WARNING !!!!"]],
      /(.*error.*)/ => [[:flag, "!!!!!! ERROR !!!!!!"]],
      /(Syntax OK)/ => [[:okay]],
    }
  end
end

class HttpdV < ShellCommand
  def cmd
    "#{command} -V"
  end

  def initialize(*args)
    super
    self.matches = {
      /Server MPM:\s+(\S+)/ => [[:okay]],
      /^ -D HTTPD_ROOT="(\S+)"/ => [[:save, :httpdroot]],
      /^ -D SERVER_CONFIG_FILE="(\S+)"/ => [[:save, :serverconfigfile]],
    }
  end

  def also_check
    if saved[:httpdroot] && saved[:serverconfigfile]
      configfile = saved[:httpdroot] + "/" + saved[:serverconfigfile]
      puts colorize(:invert) + "Main config file is at #{configfile}." + colorize(:off)
      [[ApacheFile, configfile]]
    else
      []
    end
  end
end

class HttpdS < ShellCommand
  def cmd
    "#{@command} -S"
  end

  def initialize(*args)
    super
    self.matches = {
      /default server (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
      /namevhost (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
    }
  end
end

class HttpdM < ShellCommand
  def cmd
    "#{command} -M"
  end

  def initialize(*args)
    super
    self.matches = {
      /(php5_module)/ => [[:alsocheck, Php]]
    }
  end
end

class PhpV < ShellCommand
  def cmd
    "php -v"
  end

  def initialize(*args)
    super
    self.matches = {
      /PHP (\d+\.\d+)/ => [["ne", "5.7"]],
    }
  end
end

class PhpI < ShellCommand
  def cmd
    "php -i"
  end

  def initialize(*args)
    super
    self.matches = {
      /^session.gc_maxlifetime => (\d+) => (\d+)/ => [["=", 1440], ["=", 1440]],
      /^session.gc_probability => (\d+) => (\d+)/ => [["=", 1], ["=", 1]],
      /^session.cookie_lifetime => (\d+) => (\d+)/ => [["=", 0], ["=", 0]],
      /^memory_limit => (\d+)M => (\d+)M/ => [[">=", 256], [">=", 256]],
      /^max_execution_time => (\d+) => (\d+)/ => [["=", 18000], ["=", 18000]],
      /^max_input_vars => (\d+) => (\d+)/ => [[">=", 2000], [">=", 2000]],
      /^auto_prepend_file => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
      /^auto_append_file => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
      /^disable_functions => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
      /^open_basedir => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
      /^safe_mode => (.+) => (.+)/ => [["eq", "Off"], ["eq", "Off"]],
    }
  end
end

class Collection
  attr_reader :args
  attr_accessor :children

  def initialize(*args)
    @args = args
  end

  def scan
  end

  def also_check
    if children
      return children.map {|child| [child, *args]}
    else
      return []
    end
  end
end

class Nginx < Collection
  def initialize(*args)
    super
    @children = []
  end
end

class Php < Collection
  def initialize(*args)
    super
    @children = [PhpV, PhpI]
  end
end

class Apache < Collection
  def initialize(*args)
    super
    @children = [Httpdt, HttpdV, HttpdS, HttpdM]
  end
end

class MysqlCommand < ShellCommand
  attr_reader :hostname
  attr_reader :username
  attr_reader :password
  attr_reader :dbname

  def initialize(hostname, username, password, dbname)
    @hostname = hostname
    @username = username
    @password = password
    @dbname = dbname
  end
  
  def label
    cmd
  end
  
  def openstream
    open("|mysql -h#{hostname} -u#{username} -p'#{password}' -e'#{cmd}' 2>&1") do |s|
      yield s
    end
  end
end

class MysqlStatus < MysqlCommand
  def cmd
    "show global status"
  end

  def initialize(*args)
    super
    self.matches = {
      /Aborted_clients\s(\S+)/ => [["<", 1000]],
      /Aborted_connects\s(\S+)/ => [["<", 1000]],
      /Table_locks_waited\s(\S+)/ => [["<", 100]],
      /(Access denied.*)/ => [[:flag, "Password issue?"]],
    }
  end
end

class MysqlVariables < MysqlCommand
  def cmd
    "show global variables"
  end

  def initialize(*args)
    super
    self.matches = {
      /innodb_log_file_size\s(\S+)/ => [[">", 128*1024*1024]],
      /max_heap_table_size\s(\S+)/ => [[">", 128*1024*1024, :save, :heap_table_size]],
      /tmp_table_size\s(\S+)/ => [[">", 128*1024*1024, "=", :heap_table_size]],
      /(Access denied.*)/ => [[:flag, "Password issue?"]],
    }
  end
end

class MysqlInnodbStatus < MysqlCommand
  def cmd
    "show engine innodb status\\G"
  end

  def initialize(*args)
    super
    self.matches = {
      /(Access denied.*)/ => [[:flag, "Password issue?"]],
    }
  end
end

class MysqlProcessList < MysqlCommand
  def cmd
    "show processlist"
  end

  def initialize(*args)
    super
    self.matches = {
      /(Access denied.*)/ => [[:flag, "Password issue?"]],
    }
  end
end

class MysqlSlaveStatus < MysqlCommand
  def cmd
    "show slave status"
  end

  def initialize(*args)
    super
    self.matches = {
      /(Access denied.*)/ => [[:flag, "Password issue?"]],
    }
  end
end

class Mysql < Collection
  def initialize(*args)
    super
    @children = [MysqlStatus, MysqlVariables, MysqlInnodbStatus, MysqlProcessList, MysqlSlaveStatus]
  end
end

class ConfFile < Scannable
  attr_reader :filename
  
  def initialize(filename)
    @filename = filename
  end

  def label
    filename
  end

  def openstream
    open(filename) do |s|
      yield s
    end
  end
end

class RedisConf < ConfFile
  def initialize(*args)
    super
    self.matches = {
      /^\s*(maxmemory)/ => [[:flag, "Don't set maxmemory"]],
    }
  end
end

class ApacheFile < ConfFile
  def cleanup(value)
    if /^"(.*)"$/ =~ value
      value = $1
    end
    if /^(.*)\/$/ =~ value
      value = $1
    end
    return value
  end

  def initialize(value)
    super
    self.matches = {
      /^\s*DocumentRoot\s+(\S+)/ => [[:alsocheck, DocRoot]],
    }
  end
end

class DocumentRoot < Scannable
end
  
class DocRoot < DocumentRoot
  attr_reader :rootpath

  def initialize(rootpath)
    @rootpath = Pathname.new rootpath
  end

  def label
    rootpath
  end
  
  def scan
    self.saved = Hash.new
    header
    if rootpath.exist?
      etcpath = rootpath + "app/etc"
      if etcpath.exist?
        Dir.glob(etcpath + '*.xml').each do |xmlfile|
          $checks.unshift [MagentoXmlFile, xmlfile]
        end
      else
        puts colorize(:redbg) + rootpath + " is not a magento root." + colorize(:off)
        Dir.entries(rootpath).grep(/^[^\.]/) {|f| Pathname.new f}.select {|file| File.directory? rootpath + file}.each do |dir|
          etcpath = rootpath + dir + "app/etc"
          if etcpath.exist?
            puts colorize(:invert) + "But #{etcpath} is." + colorize(:off)
            Dir.glob(etcpath + '*.xml').each do |xmlfile|
              $checks.unshift [MagentoXmlFile, xmlfile]
            end
          end
        end
      end
    else
      puts colorize(:redbg) + rootpath + " does not exist" + colorize(:off)
    end
  end
end

class XmlFile < Scannable
end

class MagentoXmlFile < XmlFile
  attr_reader :filename
  
  def initialize(filename)
    @filename = Pathname.new filename
  end

  def label
    filename
  end
  
  def scan
    self.saved = Hash.new
    header
    doc = REXML::Document.new File.new(filename, "r")
    ["cache", "full_page_cache"].each do |foo|
      doc.elements.each("config/global/#{foo}") do |cache|
        backend = cache.elements["backend"]
        unless backend.nil?
          backend = backend.text
          if backend == "memcached"
            hostname = cache.elements["memcached/servers/server/host"].text
            port = cache.elements["memcached/servers/server/port"].text
            back = Memcached
            puts colorize(:invert) + "config/global/#{foo}/memcached/servers/server #{backend} on #{hostname}:#{port}." + colorize(:off)
            $checks.unshift [Memcached, hostname, port]
          elsif backend == "Cm_Cache_Backend_Redis"
            hostname = cache.elements["backend_options/server"].text
            port = cache.elements["backend_options/port"].text
            back = Redis
            puts colorize(:invert) + "config/global/#{foo}/backend_options #{backend} on #{hostname}:#{port}." + colorize(:off)
            $checks.unshift [Redis, hostname, port]
          end
        end
      end
    end
    if redis_session = doc.elements["config/global/redis_session"]
      hostname = redis_session.elements["host"].text
      port = redis_session.elements["port"].text
      puts colorize(:invert) + "/config/global/redis_session on #{hostname}:#{port}." + colorize(:off)
      $checks.unshift [Redis, hostname, port]
    end
    if resources = doc.elements["config/global/resources"]
      connection = resources.elements["default_setup/connection"]
      hostname = connection.elements["host"].text
      username = connection.elements["username"].text
      password = connection.elements["password"].text
      dbname = connection.elements["dbname"].text
      puts colorize(:invert) + "/config/global/resources database #{dbname} on #{username}\@#{hostname}." + colorize(:off)
      $checks.unshift [Mysql, hostname, username, password, dbname]
    end
  end
end

$checks = [Ps, Sysctl, Netstat, Iostat, Dmesg, Free, Uptime]

while check = $checks.shift do
  if check.is_a? Array
    objclass = check.shift
    item = objclass.new *check
  else
    item = check.new
  end
  item.scan
  if item.respond_to? :also_check
    item.also_check.reverse.each do |value|
      unless $checks.include? value
        $checks.unshift value
      end
    end
  end
  #puts $checks.inspect
end
