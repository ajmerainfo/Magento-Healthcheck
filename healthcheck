#!/usr/bin/ruby

require 'rexml/document'
require 'socket'
require 'optparse'
require 'pathname'

$options = Hash.new
$saved = Hash.new

OptionParser.new do |opt|
  opt.on('-v', '--verbose', 'Show all output of commands') { |o| $options[:verbose] = o}
  opt.on('-q', '--quiet', "Don't show output of unimportant stuff") { |o| $options[:quiet] = o}
end.parse!

Effects = {
  :off => 0,
  :bright => 1,
  :underline => 4,
  :blink => 5,
  :invert => 7,
  :hide => 8,
  :blackfg => 30,
  :redfg => 31,
  :greenfg => 32,
  :yellowfg => 33,
  :bluefg => 34,
  :magentafg => 35,
  :cyanfg => 36,
  :whitefg => 37,
  :defaultfg => 39,
  :blackbg => 40,
  :redbg => 41,
  :greenbg => 42,
  :yellowbg => 43,
  :bluebg => 44,
  :magentabg => 45,
  :cyanbg => 46,
  :whitebg => 47,
  :defaultbg => 49,
}

def colorize(key)
  effect = Effects[key]
  return "[#{effect}m"
end

class Scannable
  attr_accessor :heading
  
  @@matches = Hash.new { |hash, key| hash[key] = Hash.new }

  class << self
    def matches
      @@matches[self]
    end
    
    def matches= (newmatches)
      newmatches.each do |key, value|
        @@matches[self][key] = value
      end
    end
  end
  
  def initialize(*args)
  end
  
  def header
    puts
    puts "#{colorize(:underline)}#{self.class.superclass}: #{colorize(:bright)}#{label}#{colorize(:off)}"
  end

  def printheader
    if $options[:quiet]
      @printedheader = false
    else
      header
      @printedheader = true
    end
  end

  def printline(line)
    unless @printedheader
      header
      @printedheader = true
    end
    if self.heading
      puts self.heading
      self.heading = nil
    end
    puts line
  end
  
  def okay(data, test, value)
    data = cleanup(data)
    if test == :save
      $saved[value] = data
      return :note
    elsif test == :count
      if $saved[value]
        $saved[value] += 1
      else
        $saved[value] = 1
      end
    elsif test == :collect
      unless $saved[value]
        $saved[value] = []
      end
      $saved[value].push data
    else
      if value.class == Symbol
        value = Integer $saved[value]
      end
      if test == "="
        return data == value
      elsif test == ">"
        return data > value
      elsif test == "<"
        return data < value
      elsif test == ">="
        return data >= value
      elsif test == "<="
        return data <= value
      elsif test == "eq"
        return data == value
      elsif test == "ne"
        return data != value
      elsif test == :okay
        return true
      elsif test == :alsocheck
        alsoscan [value, data]
        return :note
      else
        return false
      end
    end
  end

  def cleanup(value)
    if /^\d+\.\d+$/ =~ value
      value = Float value
    elsif /^\d+$/ =~ value
      value = Integer value
    end
    return(value)
  end
  
  def scanline(line)
    match = false
    showline = false
    self.class.matches.each do |key, tests|
      if key.is_a? Array
        (field, value, key) = key
        unless ($saved[field] == value)
          key = nil
        end
      end
      if key and (matchdata = (key.match line))
        match = true
        if tests.is_a? Array
          (1..tests.length).to_a.reverse.each do |i|
            testpairs = tests[i-1].dup
            endinsert = nil
            state = nil
            while test = testpairs.shift
              value = testpairs.shift
              setstate = okay(matchdata[i], test, value)
              if setstate == :note
                unless state
                  endinsert = colorize(:off) + colorize(:bright)
                  state = :note
                end
              elsif setstate
                unless state == :bad
                  endinsert = colorize(:off) + colorize(:bright)
                  state ||= :good
                end
              else
                if test == :flag
                  if value
                    endinsert = colorize(:off) + ' ' + colorize(:invert) + "#{value}" + colorize(:off) + colorize(:bright)
                  else
                    endinsert = colorize(:off) + colorize(:bright)
                  end
                else
                  endinsert = colorize(:off) + ' ' + colorize(:invert) + "(should be #{test} #{value})" + colorize(:off) + colorize(:bright)
                end
                state = :bad
              end
            end
            if state == :bad
              begininsert = colorize(:redbg)
              showline = true
            elsif state == :good
              begininsert = colorize(:greenfg)
              showline = false
            else
              begininsert = colorize(:yellowfg)
            end
            line.insert(matchdata.end(i), endinsert)
            line.insert(matchdata.begin(i), begininsert)
          end
          line = (colorize(:bright) + line + colorize(:off))
        elsif tests == :heading
          unless $options[:verbose]
            self.heading = line
            showline = false
            match = false
          end
        end
      end
    end
    if (match or $options[:verbose])
      unless $options[:quiet] and not showline
        return line
      end
    end
  end

  def scan
    printheader
    openstream do |s|
      while (line = s.gets)
        if (line = scanline line.chop)
          printline line
        end
      end
    end
    if self.class.matches == {}
      printline colorize(:invert) + 'No match rules defined yet' + colorize(:off)
    end
  end
end

class ShellCommand < Scannable
  attr_reader :command
  
  @@cmd = Hash.new

  class << self
    def cmd
      @@cmd[self]
    end

    def cmd= (cmd)
      @@cmd[self] = cmd
    end
  end

  def cmd
    @@cmd[self.class]
  end
  
  def label
    cmd
  end
  
  def openstream
    open "|#{cmd} 2>&1" do |s|
      yield s
    end
  end
end

class Cache < ShellCommand
  attr_reader :ipaddress
  attr_reader :port
  
  def initialize(ipaddress, port)
    @ipaddress = ipaddress
    @port = port
  end

  def quitcmd
    "quit"
  end

  def label
    if /^[\d\.]+$/ =~ ipaddress
      "#{self.class} at #{ipaddress}:#{port}"
    else
      "#{self.class} at #{ipaddress}"
    end
  end

  def opentcporunixsocket(ipaddress, port)
    if /^[\d\.]+$/ =~ ipaddress
      return TCPSocket.open(ipaddress, port)
    else
      return UNIXSocket.open(ipaddress)
    end
  end
  
  def openstream
    begin
      opentcporunixsocket(ipaddress, port) do |s|
        s.puts cmd + "\r"
        s.puts quitcmd + "\r"
        yield s
      end
    rescue Exception => e
      printline colorize(:redbg) + e.message + colorize(:off)
    end
  end
end

class Memcached < Cache
  self.cmd = "stats"
  self.matches = {
    /STAT evictions (\d+)/ => [["=", 0]],
  }
end

class Redis < Cache
  self.cmd = 'info'
  self.matches = {
    /redis_version:(\s+)/ => [[:save, :redis_version]],
    /evicted_keys:(\d+)/ => [["=", 0]],
    /connected_clients:(\d+)/ => [[">", 0]],
  }
  
  def initialize(*args)
    super
    if $saved[:network_addrs].include? ipaddress
      puts colorize(:invert) + "Redis is on local host. Up to 50% performance boost if switched to Unix sockets." + colorize(:off)
    end
    Sysctl.matches = {
      /vm.overcommit_memory = (\d+)/ => [["=", 1]],
    }
  end
end

class Sysctl < ShellCommand
  self.cmd = 'sysctl -a'
  self.matches = {
    /net.ipv4.tcp_tw_recycle = (\d+)/ => [["=", 1]],
    /net.ipv4.tcp_tw_reuse = (\d+)/ => [["=", 1]],
    /net.ipv4.tcp_fin_timeout = (\d+)/ => [["=", 10]],
  }
end

class Netstat < ShellCommand
  self.cmd = 'netstat -nap'
  self.matches = {
    /^Proto/ => :heading,
    /(TIME_WAIT)/ => [[:count, :time_wait]],
    /(SYN_RECV)/ => [[:count, :syn_recv]],
  }

  def process_saved
    if $saved[:time_wait]
      if $saved[:time_wait] > 10
        printline colorize(:greenfg) + "there are #{$saved[:time_wait]} connections stuck in TIME_WAIT" + colorize(:off)
      else
        printline colorize(:redbg) + "there are #{$saved[:time_wait]} connections stuck in TIME_WAIT" + colorize(:off)
      end
    end
    if $saved[:syn_recv]
      if $saved[:syn_recv] > 10
        printline colorize(:greenfg) + "there are #{$saved[:syn_recv]} connections stuck in SYN_RECV" + colorize(:off)
      else
        printline colorize(:redbg) + "there are #{$saved[:syn_recv]} connections stuck in SYN_RECV" + colorize(:off)
      end
    end
  end
end

class Iostat < ShellCommand
  self.cmd = 'iostat -dx 3 6'
  self.matches = {
    /^Device/ => :heading,
    /^\S+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+[\d\.]+\s+([\d\.]+)\s+[\d\.]+\s+[\d\.]+/ => [
      ["<", 100],
    ]
  }
end

class ScannableFile < Scannable
  attr_reader :filename
  
  def initialize(filename)
    @filename = filename
  end

  def label
    filename
  end

  def openstream
    if filename =~ /\*/
      Dir[filename].each do |f|
        alsoscan([self.class, f])
      end
    else
      begin
        open(filename) do |s|
          yield s
        end
      rescue Exception => e
        printline colorize(:redbg) + e.message + colorize(:off)
      end
    end
  end
end

class ConfFile < ScannableFile
end

class Selinux < ConfFile
  def filename
    "/etc/selinux/config"
  end
  self.matches = {
    /^SELINUX=(\w+)/ => [["ne", "enforcing"]],
  }
end

class Dmesg < ShellCommand
  self.cmd = 'dmesg'
  self.matches = {
    /^(SELinux):  Initializing.$/ => [[:alsocheck, Selinux]],
    /(segfault)/ => [[:flag]],
  }
end

class Vmstat < ShellCommand
  self.cmd = 'vmstat 1 10'
  self.matches = {
    /\sr\s+b\s/ => :heading,
    #     r     b   swpd  free  buff  cache   si      so
    /^\s+\d+\s+\d+\s+\d+\s+\d+\s+\d+\s+\d+\s+(\d+)\s+(\d+)/ => [["=", 0],["=", 0]],
  }
end

class Mpmstat < ShellCommand
  self.cmd = 'mpstat -P ALL'
end

class Free < ShellCommand
  self.cmd = 'free -mo'
  self.matches = {
    /total/ => :heading,
    /Swap:\s+\d+\s+(\d+)/ => [["=", 0]],
  }
end

class Uptime < ShellCommand
  self.cmd = 'uptime'
  self.matches = {
    /load average: ([\d\.]+), ([\d\.]+), ([\d\.]+)/ => [["<", 100], ["<", 100], ["<", 100]],
  }
end

class Last < ShellCommand
  self.cmd = 'last'
  self.matches = {
    /^reboot.*(\w\w\w \w\w\w +\d+ \d\d:\d\d - \d\d\:\d\d)/ => [[:okay]],
  }
end

class Ethtool < ShellCommand
  def initialize(interface)
    super()
    self.class.cmd = "ethtool #{interface}"
  end
  self.matches = {
    /Link detected: (\w+)/ => [["=", "yes"]],
  }
end

class Ifconfig < ShellCommand
  self.cmd = 'ifconfig -a'
  self.matches = {
    /^(\S+)\s/ => [[:alsocheck, Ethtool]],
    /inet addr:(\S+)\s/ => [[:collect, :network_addrs]],
    /inet6 addr:\s*([0-9a-f\:]+)/ => [[:collect, :network_addrs]],
    /errors:(\d+) dropped:(\d+) overruns:(\d+) frame:(\d+)/ => [["=", 0],["=", 0],["=", 0],["=", 0]],
    /errors:(\d+) dropped:(\d+) overruns:(\d+) carrier:(\d+)/ => [["=", 0],["=", 0],["=", 0],["=", 0]],
  }
end

class Iptables < ShellCommand
  self.cmd = 'iptables -L -n -v'
  self.matches = {
    /^Chain/ => :heading,
  }
end

class Lsmod < ShellCommand
  self.cmd = 'lsmod'
  self.matches = {
    /^(ip_tables)/ => [[:alsocheck, Iptables]],
  }
end

class Collection
  attr_reader :args
  attr_accessor :children
  attr_accessor :heading

  def initialize(*args)
    @args = args
  end

  def scan
  end

  def also_check
    if children
      return children.map {|child| [child, *args]}
    else
      return []
    end
  end
end

class Apache < Collection
  def initialize(*args)
    super
    @children = [Httpdt, HttpdV, HttpdS, HttpdM]
  end
end

class RedisConf < ConfFile
  self.matches = {
    /^\s*(maxmemory)/ => [[:flag, "Don't set maxmemory"]],
  }
end

class UnameA < ShellCommand
  self.cmd = 'uname -a'
  self.matches = {
    /\s\S+\s(\S+)/ => [[:save, :kernel_version]]
  }
end

class DfHt < ShellCommand
  self.cmd = 'df -hT'
  self.matches = {
    /\s(\d+)\%/ => [["<", 75]],
    /^([\d\.]+):/ => [[:flag, "NFS Mount"]],
  }
end

class DfHit < ShellCommand
  self.cmd = 'df -hiT'
  self.matches = {
    /\s(\d+)\%/ => [["<", 75]],
  }
end

class DocumentRoot < Scannable
end
  
class DocRoot < DocumentRoot
  attr_reader :rootpath

  def initialize(rootpath)
    @rootpath = Pathname.new rootpath
  end

  def label
    rootpath
  end
  
  def scanroot(rootpath)
    etcpath = rootpath + 'app/etc'
    unless $saved[:magento_roots]
      $saved[:magento_roots] = []
    end
    $saved[:magento_roots].push rootpath
    ["local.xml", "enterprise.xml"].each do |xmlfile|
      if (etcpath + xmlfile).exist?
        alsoscan [MagentoXmlFile, etcpath + xmlfile]
      end
    end
    if (rootpath + 'app/Mage.php').exist?
      alsoscan [MagVersion, rootpath]
    end
    if (logpath = rootpath + 'var/log/exception.log').exist?
      alsoscan [MagExceptionLog, logpath]
    end
    if (htaccesspath = rootpath + '.htaccess').exist?
      alsoscan [HtAccess, htaccesspath]
    end
  end
  
  def findallrootpaths(rootpath)
    rootpaths = []
    if rootpath.exist?
      etcpath = rootpath + "app/etc"
      if etcpath.exist?
        rootpaths.push rootpath
      else
        begin
          Dir.entries(rootpath).grep(/^[^\.]/) {|f| Pathname.new f}.select {|file| File.directory? rootpath + file}.each do |dir|
            etcpath = rootpath + dir + "app/etc"
            if etcpath.exist?
              rootpaths.push(rootpath + dir)
            else
              rootpaths.concat findallrootpaths(rootpath + dir)
            end
          end
        rescue Exception => e
          printline colorize(:redbg) + e.message + colorize(:off)
        end
      end
    end
    return(rootpaths)
  end
  
  def scan
    printheader
    if rootpath.exist?
      etcpath = rootpath + "app/etc"
      if etcpath.exist?
        scanroot rootpath
      else
        printline colorize(:redbg) + rootpath + " is not a magento root." + colorize(:off)
        findallrootpaths(rootpath).each do |dir|
          printline colorize(:invert) + "But #{dir} is." + colorize(:off)
          scanroot rootpath + dir
        end
      end
    else
      printline colorize(:redbg) + rootpath + " does not exist" + colorize(:off)
    end
  end
end

class NginxConf < ConfFile
end

class NgConf < NginxConf
  self.matches = {
    /^\s*include\s+(\/\S+);/ => [[:alsocheck, NgConf]],

  }
end

class LogFile < ScannableFile
end

class MysqlLog < LogFile
  self.matches = {
    /^(\d+\s+\d+:\d+:\d+).*(error)/i => [[:flag, "YYMMDD HH:MM:SS"], [:flag]],
    /^(\d+\s+\d+:\d+:\d+).*(Database was not shut down normally)/ => [[:flag, "YYMMDD HH:MM:SS"], [:flag]],
  }
end

class User < Collection
end

class Crontab < ConfFile
end

class SysCrontab < Crontab
  self.matches = {
    /^[\#]+(cron.sh)/ => [[:count, :cron]],
    /^[\#]+(cron.php)/ => [[:flag, "should call cron.sh, not cron.php"]],
  }
end

class UserCrontab < Crontab
  self.matches = {
    /^[\#]+(cron.sh)/ => [[:count, :cron]],
    /^[\#]+(cron.php)/ => [[:flag, "should call cron.sh, not cron.php"]],
  }
end

class SysCrontabs < Collection
  def scan
    alsoscan [SysCrontab, '/etc/crontab']
    alsoscan [SysCrontab, '/etc/cron.d/*']
    alsoscan [UserCrontab, '/var/spool/cron/*']
  end
end

class WebUser < User
  attr_reader :userid

  def initialize(userid)
    @userid = userid
  end

  def scan
#    crondir = Pathname.new "/var/spool/cron/"
#    if (cronfile = crondir + userid).exist?
#      alsoscan [UserCrontab, cronfile]
#    end
  end
end

class Ps < ShellCommand
  self.cmd = 'ps aux'
  self.matches = {
    /root.*\s([\/a-z]*apache2?)/ => [[:alsocheck, Apache, :save, :apache]],
    /(\w+).*\s[\/a-z]*apache2?/ => [[:alsocheck, WebUser]],
    /root.*\s([\/a-z]*httpd)/ => [[:alsocheck, Apache, :save, :apache]],
    /(\w+).*\s[\/a-z]*httpd/ => [[:alsocheck, WebUser]],
    /nginx: master process .* -c (\S*)/ => [[:alsocheck, NgConf, :save, :nginx]],
    /(memcached).*-m (\d+)/ => [[:save, :memcache], [">", 1024]],
    /redis-server\s+(\S+)/ => [[:alsocheck, RedisConf, :save, :redis]],
    /mysqld.*--log-error=([\/\.\w]+)/ => [[:alsocheck, MysqlLog]],
  }
  
end

class Httpdt < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -t"
  end

  self.matches = {
    /(.*warn.*)/ => [[:flag, "!!!! WARNING !!!!"]],
    /(.*error.*)/ => [[:flag, "!!!!!! ERROR !!!!!!"]],
    /(Syntax OK)/ => [[:okay]],
  }
end

class HttpdV < ShellCommand
  def initialize(command)
    self.class.cmd = "#{command} -V"
  end

  self.matches = {
    /Server MPM:\s+(\S+)/ => [[:okay]],
    /Server version:\s*Apache\/(\S+)/ => [[:save, :apache_version]],
    /^ -D HTTPD_ROOT="(\S+)"/ => [[:save, :httpdroot]],
    /^ -D SERVER_CONFIG_FILE="(\S+)"/ => [[:save, :serverconfigfile]],
  }

  def also_check
    if $saved[:httpdroot] && $saved[:serverconfigfile]
      configfile = $saved[:httpdroot] + "/" + $saved[:serverconfigfile]
      printline colorize(:invert) + "Main config file is at #{configfile}." + colorize(:off)
      [[ApacheFile, configfile]]
    else
      []
    end
  end
end

class MagExceptionLog < LogFile
  self.matches = {
    /exception\s'([^']*)' with message '([^']*)'/ => [[:flag], [:flag]],
    /app\/code\/local\/([^\/]+)/ => [[:flag, "not Magento code"]],
    /app\/code\/community\/([^\/]+)/ => [[:flag, "not Magento code"]],
  }
end

class HtAccess < ConfFile
end

class Messages < LogFile
  def initialize
    super('/var/log/messages')
  end
  self.matches = {
    /(ERROR)/ => [[:flag]]
  }
end

class ApacheFile < ConfFile
  def cleanup(value)
    if /^"(.*)"$/ =~ value
      value = $1
    end
    if /^(.*)\/$/ =~ value
      value = $1
    end
    return value
  end

  self.matches = {
    /^\s*DocumentRoot\s+(\S+)/ => [[:alsocheck, DocRoot]],
  }
end

class HttpdS < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -S"
  end

  self.matches = {
    /default server (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
    /namevhost (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
  }
end

class PhpV < ShellCommand
  self.cmd = 'php -v'
  self.matches = {
    /PHP (\d+\.\d+)/ => [["ne", "5.7"]],
  }
end

class PhpM < ShellCommand
  self.cmd = 'php -m'
  self.matches = {
    /^(bcmath)$/ => [[:save, :bcmath]],
    /^(memcache)$/ => [[:save, :cache]],
    /^(redis)$/ => [[:save, :cache]],
  }

  def process_saved
    unless $saved[:bcmath]
      printline colorize(:invert) + "bcmath is a required php module" + colorize(:off)
    end
    unless $saved[:cache]
      printline colorize(:invert) + "either memcache or redis modules are required" + colorize(:off)
    end
  end
end

class PhpI < ShellCommand
  self.cmd = 'php -i'
  self.matches = {
    /^([a-z]+)$/i => [[:save, :section]],
    [:section, "session",  /^session.gc_maxlifetime => (\d+) => (\d+)/]  => [["=", 1440], ["=", 1440]],
    [:section, "session",  /^session.gc_probability => (\d+) => (\d+)/]  => [["=", 1], ["=", 1]],
    [:section, "session",  /^session.cookie_lifetime => (\d+) => (\d+)/] => [["=", 0], ["=", 0]],
    [:section, "Core",     /^PHP Version => (\S+)/]                       => [[:save, :php_version]],
    [:section, "Core",     /^memory_limit => (\d+)M => (\d+)M/]          => [[">=", 256], [">=", 256]],
    [:section, "Core",     /^max_execution_time => (\d+) => (\d+)/]      => [["=", 18000], ["=", 18000]],
    [:section, "Core",     /^max_input_vars => (\d+) => (\d+)/]          => [[">=", 2000], [">=", 2000]],
    [:section, "Core",     /^auto_prepend_file => (.+) => (.+)/]         => [["eq", "no value"], ["eq", "no value"]],
    [:section, "Core",     /^auto_append_file => (.+) => (.+)/]          => [["eq", "no value"], ["eq", "no value"]],
    [:section, "Core",     /^disable_functions => (.+) => (.+)/]         => [["eq", "no value"], ["eq", "no value"]],
    [:section, "Core",     /^open_basedir => (.+) => (.+)/]              => [["eq", "no value"], ["eq", "no value"]],
    [:section, "Core",     /^safe_mode => (.+) => (.+)/]                 => [["eq", "Off"], ["eq", "Off"]],
    [:section, "memcache", /^Version => (\S+)/]                          => [["eq", "3.0.5", :save, :memcache_version]],
    [:section, "mysql",    /^Client API version => (.+)/]               => [[:save, :mysql_client_api_version]],
  }
end

class Php < Collection
  def initialize(*args)
    super
    @children = [PhpV, PhpM, PhpI]
  end
end

class HttpdM < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -M"
  end

  self.matches = {
    /(php5_module)/ => [[:alsocheck, Php]]
  }
end

class MysqlCommand < ShellCommand
  attr_reader :hostname
  attr_reader :username
  attr_reader :password
  attr_reader :dbname

  def initialize(hostname, username, password, dbname)
    @hostname = hostname
    @username = username
    @password = password
    @dbname = dbname
  end
  
  def label
    cmd
  end
  
  def openstream
    if password == ''
      shellcmd = "mysql -h#{hostname} -u#{username} -e'#{cmd}'"
    else
      shellcmd = "mysql -h#{hostname} -u#{username} -p'#{password}' -e'#{cmd}'"
    end
    open("|#{shellcmd} 2>&1") do |s|
      yield s
    end
  end
end

class MysqlStatus < MysqlCommand
  self.cmd = 'show global status'
  self.matches = {
    /Aborted_clients\s(\S+)/ => [["<", 1000]],
    /Aborted_connects\s(\S+)/ => [["<", 1000]],
    /Table_locks_waited\s(\S+)/ => [["<", 100]],
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlVariables < MysqlCommand
  self.cmd = 'show global variables'
  self.matches = {
    /innodb_log_file_size\s(\S+)/ => [[">", 128*1024*1024]],
    /max_heap_table_size\s(\S+)/ => [[">", 128*1024*1024, :save, :heap_table_size]],
    /tmp_table_size\s(\S+)/ => [[">", 128*1024*1024, "=", :heap_table_size]],
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlInnodbStatus < MysqlCommand
  self.cmd = 'show engine innodb status\\G'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlProcessList < MysqlCommand
  self.cmd = 'show processlist'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlSlaveStatus < MysqlCommand
  self.cmd = 'show slave status'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class Mysql < Collection
  def initialize(*args)
    super
    @children = [MysqlStatus, MysqlVariables, MysqlInnodbStatus, MysqlProcessList, MysqlSlaveStatus]
  end
end

class MagentoVersion < ShellCommand
end

class MagVersion < MagentoVersion
  attr_reader :path
  
  def initialize(path)
    @path = path
    self.class.cmd = "php -r \"require \'#{path}/app/Mage.php\'; echo Mage::getVersion();\""
  end

  def label
    "Magento install at #{path}"
  end
  
  def scan
    printheader
    openstream do |s|
      if version = s.gets
        $saved[:magento_version] = version
        printline colorize(:greenfg) + version + colorize(:off)
      else
        printline colorize(:redbg) + "couldn't read the version" + colorize(:off)
      end
    end
  end
end

class XmlFile < ScannableFile
end

class MagentoXmlFile < XmlFile
  attr_reader :filename
  
  def initialize(filename)
    @filename = Pathname.new filename
  end

  def label
    filename
  end

  def gettext(session, elementname)
    if element = session.elements[elementname]
      return element.text
    end
  end
  
  def scan
    printheader
    if $options[:verbose]
      openstream do |s|
        while (line = s.gets)
          puts line
        end
      end
    end
    doc = REXML::Document.new File.new(filename, "r")
    ["cache", "full_page_cache"].each do |foo|
      doc.elements.each("config/global/#{foo}") do |cache|
        if backend = gettext(cache,"backend")
          if backend == "memcached"
            if ipaddress = gettext(cache, "memcached/servers/server/host")
              if port = gettext(cache, "memcached/servers/server/port")
                back = Memcached
                printline colorize(:invert) + "config/global/#{foo}/memcached/servers/server #{backend} on #{ipaddress}:#{port}." + colorize(:off)
                alsoscan [Memcached, ipaddress, port]
              else
                printline colorize(:redbg) + "port not properly defined in config/global/#{foo}/memcached/servers/server/port" + colorize(:off)
              end
            else
              printline colorize(:redbg) + "host not properly defined in config/global/#{foo}/memcached/servers/server/host" + colorize(:off)
            end
          elsif backend == "Cm_Cache_Backend_Redis"
            if ipaddress = gettext(cache, "backend_options/server")
              if port = gettext(cache, "backend_options/port")
                back = Redis
                printline colorize(:invert) + "config/global/#{foo}/backend_options #{backend} on #{ipaddress}:#{port}." + colorize(:off)
                alsoscan [Redis, ipaddress, port]
              else
                printline colorize(:redbg) + "port not properly defined in config/global/#{foo}/backend_options/port" + colorize(:off)
              end
            else
              printline colorize(:redbg) + "ipaddress not properly defined in config/global/#{foo}/backend_options/server" + colorize(:off)
            end
          end
        end
      end
    end
    if redis_session = doc.elements["config/global/redis_session"]
      if ipaddress = gettext(redis_session, "host")
        if port = gettext(redis_session, "port")
          printline colorize(:invert) + "/config/global/redis_session on #{ipaddress}:#{port}." + colorize(:off)
          alsoscan [Redis, ipaddress, port]
        else
          printline colorize(:redbg) + "port not properly defined in config/global/redis_session" + colorize(:off)
        end
      else
        printline colorize(:redbg) + "host not properly defined in config/global/redis_session" + colorize(:off)
      end
    end
    if resources = doc.elements["config/global/resources"]
      connection = resources.elements["default_setup/connection"]
      if ipaddress = gettext(connection, "host")
        if username = gettext(connection, "username")
          if password = gettext(connection, "password")
            if dbname = gettext(connection, "dbname")
              printline colorize(:invert) + "/config/global/resources database #{dbname} on #{username}\@#{ipaddress}." + colorize(:off)
              alsoscan [Mysql, ipaddress, username, password, dbname]
            else
              printline colorize(:redbg) + "dbname not properly defined in default_setup/connection" + colorize(:off)
            end
          else
            printline colorize(:redbg) + "password not properly defined in default_setup/connection" + colorize(:off)
          end
        else
          printline colorize(:redbg) + "username not properly defined in default_setup/connection" + colorize(:off)
        end
      else
        printline colorize(:redbg) + "ipaddress not properly defined in default_setup/connection" + colorize(:off)
      end
    end
  end
end

$oldchecks = []
$checks = [UnameA, Netstat, Ifconfig, DfHt, DfHit, Ps, SysCrontabs, Sysctl, Iostat, Vmstat, Dmesg, Messages, Lsmod, Free, Uptime, Last]

def alsoscan(item)
  unless ($checks.include? item) or ($oldchecks.include? item)
    $checks.unshift item
  end
end

def showsummary
  cmd = "sha1sum #{$0}"
  sha1sum = `#{cmd}`
  sha1sum = sha1sum.split(/\s+/)[0]
  
  puts
  puts "#{colorize(:underline)}#{colorize(:bright)}Summary#{colorize(:off)}"
  puts "Healthcheck version: #{sha1sum}"
  puts "Magento version: #{$saved[:magento_version]}"
  puts "Kernel version: #{$saved[:kernel_version]}"
  if $saved[:apache_version]
    puts "Apache version: #{$saved[:apache_version]}"
  end
  if $saved[:nginx]
    puts "Running nginx"
  end
  if $saved[:memcache_version]
    puts "memcache version: #{$saved[:memcache_version]}"
  end
  if $saved[:redis_version]
    puts "Redis version: #{$saved[:redis_version]}"
  end
  if $saved[:php_version]
    puts "PHP version: #{$saved[:php_version]}"
  end
  if $saved[:mysql_client_api_version]
    puts "Mysql Client API version: #{$saved[:mysql_client_api_version]}"
  end
  puts "Network interfaces: #{$saved[:network_addrs].join(', ')}"
  puts "Magento roots:"
  if $saved[:magento_roots]
    puts "\t" + $saved[:magento_roots].join("\n\t")
  else
    puts colorize(:redbg) + "Couldn't find any magento roots" + colorize(:off)
  end
  if $saved[:cron] != 1
    puts colorize(:redbg) + "cron.sh is called in #{$saved[:cron] || 0} places." + colorize(:off)
  end
end
if ENV['USER'] != 'root'
    puts colorize(:redbg) + "Not running as root.  May not be able to get all info." + colorize(:off)
end
while check = $checks.shift do
  if check.is_a? Array
    objclass = check.shift
    item = objclass.new *check
    $oldchecks.unshift [objclass, *check.dup]
  else
    $oldchecks.unshift check
    item = check.new
  end
  item.scan
  item.heading = nil
  if item.respond_to? :process_saved
    item.process_saved
  end
  if item.respond_to? :also_check
    item.also_check.reverse.each do |value|
      alsoscan value
    end
  end
  #puts $checks.inspect
end
showsummary
