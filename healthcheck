#!/usr/bin/ruby

require 'rexml/document'
require 'socket'
require 'optparse'
require 'pathname'

$options = Hash.new
OptionParser.new do |opt|
  opt.on('-v', '--verbose', 'Show all output of commands') { |o| $options[:verbose] = o}
end.parse!

Effects = {
  :off => 0,
  :bright => 1,
  :underline => 4,
  :blink => 5,
  :invert => 7,
  :hide => 8,
  :blackfg => 30,
  :redfg => 31,
  :greenfg => 32,
  :yellowfg => 33,
  :bluefg => 34,
  :magentafg => 35,
  :cyanfg => 36,
  :whitefg => 37,
  :defaultfg => 39,
  :blackbg => 40,
  :redbg => 41,
  :greenbg => 42,
  :yellowbg => 43,
  :bluebg => 44,
  :magentabg => 45,
  :cyanbg => 46,
  :whitebg => 47,
  :defaultbg => 49,
}

def colorize(key)
  effect = Effects[key]
  return "[#{effect}m"
end

class Scannable
  attr_accessor :saved

  @@matches = Hash.new { |hash, key| hash[key] = Hash.new }
  
  class << self
    def matches
      @@matches[self]
    end
    
    def matches= (newmatches)
      newmatches.each do |key, value|
        @@matches[self][key] = value
      end
    end
  end
  
  def initialize(*args)
  end
  
  def header
    puts
    puts "#{colorize(:underline)}#{self.class.superclass}: #{colorize(:bright)}#{label}#{colorize(:off)}"
  end

  def okay(data, test, value)
    data = cleanup(data)
    if test == :save
      saved[value] = data
      return true
    else
      if value.class == Symbol
        value = Integer saved[value]
      end
      if test == "="
        return ((Integer data) == value)
      elsif test == ">"
        return ((Integer data) > value)
      elsif test == "<"
        return ((Integer data) < value)
      elsif test == ">="
        return ((Integer data) >= value)
      elsif test == "<="
        return ((Integer data) <= value)
      elsif test == "eq"
        return (data == value)
      elsif test == "ne"
        return (data != value)
      elsif test == :okay
        return true
      elsif test == :alsocheck
        unless $checks.include? [value, data]
          $checks.unshift [value, data]
        end
        return true
      else
        return false
      end
    end
  end

  def cleanup(value)
    return(value)
  end
  
  def scanline(line)
    match = false
    self.class.matches.each do |key, tests|
      if matchdata = (key.match line)
        match = true
        (1..tests.length).to_a.reverse.each do |i|
          testpairs = tests[i-1].dup
          endinsert = nil
          while test = testpairs.shift
            value = testpairs.shift
            if okay(matchdata[i], test, value)
              unless endinsert
                endinsert = colorize(:off) + colorize(:bright)
                begininsert = colorize(:greenfg)
              end
            else
              if test == :flag
                endinsert = colorize(:off) + ' ' + colorize(:invert) + "#{value}" + colorize(:off) + colorize(:bright)
              else
                endinsert = colorize(:off) + ' ' + colorize(:invert) + "(should be #{test} #{value})" + colorize(:off) + colorize(:bright)
              end
              begininsert = colorize(:redbg)
            end
          end
          line.insert(matchdata.end(i), endinsert)
          line.insert(matchdata.begin(i), begininsert)
        end
        line = (colorize(:bright) + line + colorize(:off))
      end
    end
    if match or $options[:verbose]
      return line
    end
  end
  
  def scan
    self.saved = Hash.new
    header
    openstream do |s|
      while (line = s.gets)
        if (line = scanline line.chop)
          puts line
        end
      end
    end
    if self.class.matches == {}
      puts colorize(:invert) + 'No match rules defined yet' + colorize(:off)
    end
  end
end

class ShellCommand < Scannable
  attr_reader :command
  
  @@cmd = Hash.new

  class << self
    def cmd
      @@cmd[self]
    end

    def cmd= (cmd)
      @@cmd[self] = cmd
    end
  end

  def cmd
    @@cmd[self.class]
  end
  
  def label
    cmd
  end
  
  def openstream
    open "|#{cmd} 2>&1" do |s|
      yield s
    end
  end
end

class Cache < ShellCommand
  attr_reader :hostname
  attr_reader :port
  
  def initialize(hostname, port)
    @hostname = hostname
    @port = port
  end

  def quitcmd
    "quit"
  end

  def label
    "#{self.class} at #{hostname}:#{port}"
  end

  def openstream
    TCPSocket.open(hostname, port) do |s|
      s.puts cmd + "\r"
      s.puts quitcmd + "\r"
      yield s
    end
  end
end

class Memcached < Cache
  self.cmd = "stats"
  self.matches = {
    /STAT evictions (\d+)/ => [["=", 0]],
  }
end

class Redis < Cache
  self.cmd = 'info'
  self.matches = {
    /evicted_keys:(\d+)/ => [["=", 0]],
    /connected_clients:(\d+)/ => [[">", 0]],
  }
  
  def initialize(*args)
    super
    Sysctl.matches = {
      /vm.overcommit_memory = (\d+)/ => [["=", 1]],
    }
  end
end

class Sysctl < ShellCommand
  self.cmd = 'sysctl -a'
  self.matches = {
    /net.ipv4.tcp_tw_recycle = (\d+)/ => [["=", 1]],
    /net.ipv4.tcp_tw_reuse = (\d+)/ => [["=", 1]],
    /net.ipv4.tcp_fin_timeout = (\d+)/ => [["=", 10]],
  }
end

class Netstat < ShellCommand
  self.cmd = 'netstat -nap'
end

class Iostat < ShellCommand
  self.cmd = 'iostat -dx 3 6'
end

class Dmesg < ShellCommand
  self.cmd = 'dmesg'
end

class Vmstat < ShellCommand
  self.cmd = 'vmstat 1 10'
end

class Mpmstat < ShellCommand
  self.cmd = 'mpstat -P ALL'
end

class Free < ShellCommand
  self.cmd = 'free -mo'
end

class Top < ShellCommand
  self.cmd = 'top -n1'
end

class Last < ShellCommand
  self.cmd = 'last'
end

class Ethtool < ShellCommand
  def initialize(interface)
    super()
    self.class.cmd = "ethtool #{interface}"
  end
end

class Ifconfig < ShellCommand
  self.cmd = 'ifconfig -a'
  self.matches = {
    /^(\S+)\s/ => [[:alsocheck, Ethtool]],
    /errors:(\d+) dropped:(\d+) overruns:(\d+) frame:(\d+)/ => [["=", 0],["=", 0],["=", 0],["=", 0]],
    /errors:(\d+) dropped:(\d+) overruns:(\d+) carrier:(\d+)/ => [["=", 0],["=", 0],["=", 0],["=", 0]],
  }
end

class Iptables < ShellCommand
  self.cmd = 'iptables -L -n -v'
end

class Lsmod < ShellCommand
  self.cmd = 'lsmod'
  self.matches = {
    /^(ip_tables)/ => [[:alsocheck, Iptables]],
  }
end

class Collection
  attr_reader :args
  attr_accessor :children

  def initialize(*args)
    @args = args
  end

  def scan
  end

  def also_check
    if children
      return children.map {|child| [child, *args]}
    else
      return []
    end
  end
end

class Apache < Collection
  def initialize(*args)
    super
    @children = [Httpdt, HttpdV, HttpdS, HttpdM]
  end
end

class Nginx < Collection
  def initialize(*args)
    super
    @children = []
  end
end

class ConfFile < Scannable
  attr_reader :filename
  
  def initialize(filename)
    @filename = filename
  end

  def label
    filename
  end

  def openstream
    open(filename) do |s|
      yield s
    end
  end
end

class RedisConf < ConfFile
  self.matches = {
    /^\s*(maxmemory)/ => [[:flag, "Don't set maxmemory"]],
  }
end

class UnameA < ShellCommand
  self.cmd = 'uname -a'
  self.matches = {
    /\s\S+\s(\S+)/ => [[:okay]]
  }
end

class DfHit < ShellCommand
  self.cmd = 'df -hiT'
  self.matches = {
    /\s(\d+)\%/ => [["<", 75]],
  }
end

class Ps < ShellCommand
  self.cmd = 'ps aux'
  self.matches = {
    /root.*\s([\/a-z]*apache2?)/ => [[:alsocheck, Apache]],
    /root.*\s([\/a-z]*httpd)/ => [[:alsocheck, Apache]],
    /nginx: master process (\S*)/ => [[:alsocheck, Nginx]],
    /(memcached).*-m (\d+)/ => [[:okay], [">", 1024]],
    /redis-server\s+(\S+)/ => [[:alsocheck, RedisConf]],
  }
  
end

class Httpdt < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -t"
  end

  self.matches = {
    /(.*warn.*)/ => [[:flag, "!!!! WARNING !!!!"]],
    /(.*error.*)/ => [[:flag, "!!!!!! ERROR !!!!!!"]],
    /(Syntax OK)/ => [[:okay]],
  }
end

class HttpdV < ShellCommand
  def initialize(command)
    self.class.cmd = "#{command} -V"
  end

  self.matches = {
    /Server MPM:\s+(\S+)/ => [[:okay]],
    /^ -D HTTPD_ROOT="(\S+)"/ => [[:save, :httpdroot]],
    /^ -D SERVER_CONFIG_FILE="(\S+)"/ => [[:save, :serverconfigfile]],
  }

  def also_check
    if saved[:httpdroot] && saved[:serverconfigfile]
      configfile = saved[:httpdroot] + "/" + saved[:serverconfigfile]
      puts colorize(:invert) + "Main config file is at #{configfile}." + colorize(:off)
      [[ApacheFile, configfile]]
    else
      []
    end
  end
end

class DocumentRoot < Scannable
end
  
class DocRoot < DocumentRoot
  attr_reader :rootpath

  def initialize(rootpath)
    @rootpath = Pathname.new rootpath
  end

  def label
    rootpath
  end
  
  def scan
    self.saved = Hash.new
    header
    if rootpath.exist?
      etcpath = rootpath + "app/etc"
      if etcpath.exist?
        ["local.xml", "enterprise.xml"].each do |xmlfile|
          if (etcpath + xmlfile).exist?
            $checks.unshift [MagentoXmlFile, xmlfile]
          end
        end
      else
        puts colorize(:redbg) + rootpath + " is not a magento root." + colorize(:off)
        Dir.entries(rootpath).grep(/^[^\.]/) {|f| Pathname.new f}.select {|file| File.directory? rootpath + file}.each do |dir|
          etcpath = rootpath + dir + "app/etc"
          if etcpath.exist?
            puts colorize(:invert) + "But #{etcpath} is." + colorize(:off)
            ["local.xml", "enterprise.xml"].each do |xmlfile|
              if (etcpath + xmlfile).exist?
                $checks.unshift [MagentoXmlFile, etcpath + xmlfile]
              end
            end
          end
        end
      end
    else
      puts colorize(:redbg) + rootpath + " does not exist" + colorize(:off)
    end
  end
end

class ApacheFile < ConfFile
  def cleanup(value)
    if /^"(.*)"$/ =~ value
      value = $1
    end
    if /^(.*)\/$/ =~ value
      value = $1
    end
    return value
  end

  self.matches = {
    /^\s*DocumentRoot\s+(\S+)/ => [[:alsocheck, DocRoot]],
  }
end

class HttpdS < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -S"
  end

  self.matches = {
    /default server (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
    /namevhost (\S+)\s+\(([^:]+):/ => [[:okay], [:alsocheck, ApacheFile]],
  }
end

class PhpV < ShellCommand
  self.cmd = 'php -v'
  self.matches = {
    /PHP (\d+\.\d+)/ => [["ne", "5.7"]],
  }
end

class PhpM < ShellCommand
  self.cmd = 'php -m'
  self.matches = {
    /^(bcmath)/ => [[:save, :bcmath]],
    /^(memcache)/ => [[:save, :cache]],
    /^(redis)/ => [[:save, :cache]],
  }

  def process_saved
    unless self.saved[:bcmath]
      puts colorize(:invert) + "bcmath is a required php module" + colorize(:off)
    end
    unless self.saved[:cache]
      puts colorize(:invert) + "either memcache or redis modules are required" + colorize(:off)
    end
  end
end

class PhpI < ShellCommand
  self.cmd = 'php -i'
  self.matches = {
    /^session.gc_maxlifetime => (\d+) => (\d+)/ => [["=", 1440], ["=", 1440]],
    /^session.gc_probability => (\d+) => (\d+)/ => [["=", 1], ["=", 1]],
    /^session.cookie_lifetime => (\d+) => (\d+)/ => [["=", 0], ["=", 0]],
    /^memory_limit => (\d+)M => (\d+)M/ => [[">=", 256], [">=", 256]],
    /^max_execution_time => (\d+) => (\d+)/ => [["=", 18000], ["=", 18000]],
    /^max_input_vars => (\d+) => (\d+)/ => [[">=", 2000], [">=", 2000]],
    /^auto_prepend_file => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
    /^auto_append_file => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
    /^disable_functions => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
    /^open_basedir => (.+) => (.+)/ => [["eq", "no value"], ["eq", "no value"]],
    /^safe_mode => (.+) => (.+)/ => [["eq", "Off"], ["eq", "Off"]],
  }
end

class Php < Collection
  def initialize(*args)
    super
    @children = [PhpV, PhpM, PhpI]
  end
end

class HttpdM < ShellCommand
  def initialize(command)
    super()
    self.class.cmd = "#{command} -M"
  end

  self.matches = {
    /(php5_module)/ => [[:alsocheck, Php]]
  }
end

class MysqlCommand < ShellCommand
  attr_reader :hostname
  attr_reader :username
  attr_reader :password
  attr_reader :dbname

  def initialize(hostname, username, password, dbname)
    @hostname = hostname
    @username = username
    @password = password
    @dbname = dbname
  end
  
  def label
    cmd
  end
  
  def openstream
    open("|mysql -h#{hostname} -u#{username} -p'#{password}' -e'#{cmd}' 2>&1") do |s|
      yield s
    end
  end
end

class MysqlStatus < MysqlCommand
  self.cmd = 'show global status'
  self.matches = {
    /Aborted_clients\s(\S+)/ => [["<", 1000]],
    /Aborted_connects\s(\S+)/ => [["<", 1000]],
    /Table_locks_waited\s(\S+)/ => [["<", 100]],
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlVariables < MysqlCommand
  self.cmd = 'show global variables'
  self.matches = {
    /innodb_log_file_size\s(\S+)/ => [[">", 128*1024*1024]],
    /max_heap_table_size\s(\S+)/ => [[">", 128*1024*1024, :save, :heap_table_size]],
    /tmp_table_size\s(\S+)/ => [[">", 128*1024*1024, "=", :heap_table_size]],
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlInnodbStatus < MysqlCommand
  self.cmd = 'show engine innodb status\\G'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlProcessList < MysqlCommand
  self.cmd = 'show processlist'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class MysqlSlaveStatus < MysqlCommand
  self.cmd = 'show slave status'
  self.matches = {
    /(Access denied.*)/ => [[:flag, "Password issue?"]],
  }
end

class Mysql < Collection
  def initialize(*args)
    super
    @children = [MysqlStatus, MysqlVariables, MysqlInnodbStatus, MysqlProcessList, MysqlSlaveStatus]
  end
end

class XmlFile < Scannable
end

class MagentoXmlFile < XmlFile
  attr_reader :filename
  
  def initialize(filename)
    @filename = Pathname.new filename
  end

  def label
    filename
  end
  
  def scan
    self.saved = Hash.new
    header
    doc = REXML::Document.new File.new(filename, "r")
    ["cache", "full_page_cache"].each do |foo|
      doc.elements.each("config/global/#{foo}") do |cache|
        backend = cache.elements["backend"]
        unless backend.nil?
          backend = backend.text
          if backend == "memcached"
            hostname = cache.elements["memcached/servers/server/host"].text
            port = cache.elements["memcached/servers/server/port"].text
            back = Memcached
            puts colorize(:invert) + "config/global/#{foo}/memcached/servers/server #{backend} on #{hostname}:#{port}." + colorize(:off)
            $checks.unshift [Memcached, hostname, port]
          elsif backend == "Cm_Cache_Backend_Redis"
            hostname = cache.elements["backend_options/server"].text
            port = cache.elements["backend_options/port"].text
            back = Redis
            puts colorize(:invert) + "config/global/#{foo}/backend_options #{backend} on #{hostname}:#{port}." + colorize(:off)
            $checks.unshift [Redis, hostname, port]
          end
        end
      end
    end
    if redis_session = doc.elements["config/global/redis_session"]
      hostname = redis_session.elements["host"].text
      port = redis_session.elements["port"].text
      puts colorize(:invert) + "/config/global/redis_session on #{hostname}:#{port}." + colorize(:off)
      $checks.unshift [Redis, hostname, port]
    end
    if resources = doc.elements["config/global/resources"]
      connection = resources.elements["default_setup/connection"]
      hostname = connection.elements["host"].text
      username = connection.elements["username"].text
      password = connection.elements["password"].text
      dbname = connection.elements["dbname"].text
      puts colorize(:invert) + "/config/global/resources database #{dbname} on #{username}\@#{hostname}." + colorize(:off)
      $checks.unshift [Mysql, hostname, username, password, dbname]
    end
  end
end

$checks = [UnameA, Ifconfig, DfHit, Ps, Sysctl, Netstat, Iostat, Vmstat, Dmesg, Lsmod, Free, Top, Last]

while check = $checks.shift do
  if check.is_a? Array
    objclass = check.shift
    item = objclass.new *check
  else
    item = check.new
  end
  item.scan
  if item.respond_to? :process_saved
    item.process_saved
  end
  if item.respond_to? :also_check
    item.also_check.reverse.each do |value|
      unless $checks.include? value
        $checks.unshift value
      end
    end
  end
  #puts $checks.inspect
end
